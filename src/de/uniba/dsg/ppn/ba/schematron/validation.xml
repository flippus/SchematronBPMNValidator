<?xml version="1.0" encoding="utf-8"?>
<iso:schema xmlns="http://purl.oclc.org/dsdl/schematron" 
    xmlns:iso="http://purl.oclc.org/dsdl/schematron" 
    xmlns:ppn="http://ppn.lspi.uni-bamberg.de" 
    queryBinding="xslt2" schemaVersion="ISO19757-3">
    <iso:title>ISO schematron validation file for descriptive extended constraints</iso:title>
    <iso:ns prefix='bpmn' uri='http://www.omg.org/spec/BPMN/20100524/MODEL'/>
    <let name="eventDefinitions" value="bpmn:eventDefinitionRef | bpmn:messageEventDefinition | bpmn:timerEventDefinition | bpmn:escalationEventDefinition | bpmn:conditionalEventDefinition | bpmn:linkEventDefinition | bpmn:errorEventDefinition | bpmn:cancelEventDefinition | bpmn:compensationEventDefinition | bpmn:signalEventDefinition | bpmn:terminateEventDefinition" />
    <let name="associations" value="//bpmn:association" />
    <let name="textAnnotations" value="//bpmn:textAnnotation" />
    <let name="groups" value="//bpmn:group" />
    <let name="task" value="bpmn:task | bpmn:sendTask | bpmn:receiveTask | bpmn:serviceTask | bpmn:userTask | bpmn:manualTask | bpmn:scriptTask | bpmn:businessRuleTask"/>
    <let name="subProcess" value="bpmn:subProcess | bpmn:transaction | bpmn:adHocSubProcess"/>
    <let name="activity" value="$task | $subProcess | bpmn:callActivity"/>
    <let name="event" value="bpmn:startEvent | bpmn:endEvent | bpmn:intermediateThrowEvent | bpmn:intermediateCatchEvent | bpmn:boundaryEvent"/>
    <let name="gateway" value="bpmn:exclusiveGateway | bpmn:parallelGateway | bpmn:inclusiveGateway | bpmn:complexGateway | bpmn:eventBasedGateway"/>
    
    <let name="sequenceFlows" value="//bpmn:sequenceFlow"/>
    
    <!-- Your constraints go here -->
    <iso:pattern name="EXT.006">
        <iso:rule context="bpmn:sequenceFlow[@targetRef]">
            <iso:assert test="not((string(./@targetRef) = $associations/@id) or (string(./@targetRef) = $textAnnotations/@id) or (string(./@targetRef) = $groups/@id))">An Artifact MUST NOT be a target for a Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.007">
        <iso:rule context="bpmn:sequenceFlow[@sourceRef]">
            <iso:assert test="not((string(./@sourceRef) = $associations/@id) or (string(./@sourceRef) = $textAnnotations/@id) or (string(./@sourceRef) = $groups/@id))">An Artifact MUST NOT be a source for a Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>

    <iso:pattern name="EXT.008">
        <iso:rule context="bpmn:messageFlow[@targetRef]">
            <iso:assert test="not((string(./@targetRef) = $associations/@id) or (string(./@targetRef) = $textAnnotations/@id) or (string(./@targetRef) = $groups/@id))">An Artifact MUST NOT be a target for a Message Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.009">
        <iso:rule context="bpmn:messageFlow[@sourceRef]">
            <iso:assert test="not((string(./@sourceRef) = $associations/@id) or (string(./@sourceRef) = $textAnnotations/@id) or (string(./@sourceRef) = $groups/@id))">An Artifact MUST NOT be a source for a Message Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <!--
    <iso:pattern name="EXT.021">
        <let name="subProcesses" value="//bpmn:subProcess"/>
        <iso:rule context="bpmn:*[./@id = string($sequenceFlows/@sourceRef)]">
            <iso:assert test="./@id = $activity/@id or ./@id = $gateway/@id or ./@id = $event/@id and not(./@id = $subProcesses/@id and $subProcesses[string(@triggeredByEvent) = 'true'])">For a Process: Of the types of FlowNode, only Activities, Gateways, and Events can be the source. However, Activities that are Event SubProcesses are not allowed to be a source</iso:assert>
        </iso:rule>
    </iso:pattern> -->
    
    <!--
    <iso:pattern name="EXT.023">
        <let name="allElements" value="//bpmn:*"/>
        <iso:rule context="bpmn:sequenceFlow">
            <iso:assert test="$allElements[@id = string(./@targetRef) and ./@id = string(@incoming)]">The source and target element of the sequence flow must reference the SequenceFlow definition using their incoming/outcoming attributes.</iso:assert>
        </iso:rule>
        <iso:rule context="bpmn:sequenceFlow">
            <iso:assert test="string(./@sourceRef) = $allElements/@id and ./@id = string($allElements/@outgoing)">The source and target element of the sequence flow must reference the SequenceFlow definition using their incoming/outcoming attributes.</iso:assert>
        </iso:rule>
    </iso:pattern> 
    -->
           
    <iso:pattern name="EXT.036">
        <iso:rule context="bpmn:process">
            <iso:assert test="not(bpmn:choreographyTask or bpmn:subChoreography or bpmn:callChoreography)">A Process must not contain Choreography Activities</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.056">
        <iso:rule context="$subProcess">
            <iso:assert test="not(bpmn:choreographyTask or bpmn:subChoreography or bpmn:callChoreography)">A SubProcess must not contain Choreography Activities</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.079">
        <iso:rule context="$subProcess">
            <iso:assert test="not(bpmn:ioSpecification)">InputOutputSpecifications are not allowed in SubProcesses</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <!--
    <iso:pattern name="EXT.084">
        <let name="inputSets" value="//bpmn:InputSet"/>
        <iso:rule context="bpmn:dataInput">
            <iso:assert test="./id = $inputSets/bpmn:dataInputRefs">A DataInput must be referenced by at least one InputSet</iso:assert>
        </iso:rule>
    </iso:pattern>
    -->
    
    <iso:pattern name="EXT.096">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="not(bpmn:incoming)">A Start Event must not have an incoming sequence flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.097">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="parent::*/bpmn:startEvent">A Start event must be present when an End event is used in the same process level</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.099">
        <let name="callActivities" value="//bpmn:callActivity"/>
        <iso:rule context="bpmn:process[./@id = string($callActivities/@calledElement)]">
            <iso:assert test="not(count(./bpmn:startEvent) = (count(./bpmn:startEvent/bpmn:eventDefinitionRef/..) + count(./bpmn:startEvent/bpmn:messageEventDefinition/..) + count(./bpmn:startEvent/bpmn:timerEventDefinition/..) + count(./bpmn:startEvent/bpmn:escalationEventDefinition/..) + count(./bpmn:startEvent/bpmn:conditionalEventDefinition/..) + count(./bpmn:startEvent/bpmn:linkEventDefinition/..) + count(./bpmn:startEvent/bpmn:errorEventDefinition/..) + count(./bpmn:startEvent/bpmn:cancelEventDefinition/..) + count(./bpmn:startEvent/bpmn:compensationEventDefinition/..) + count(./bpmn:startEvent/bpmn:signalEventDefinition/..) + count(./bpmn:startEvent/bpmn:terminateEventDefinition/..)))">Referenced process must have at least one None Start Event</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.100">
        <iso:rule context="bpmn:subProcess/bpmn:startEvent | bpmn:transaction/bpmn:startEvent | bpmn:adHocSubProcess/bpmn:startEvent">
            <iso:assert test="not(./$eventDefinitions)">No EventDefinition is allowed for Start Events in Sub-Process definitions</iso:assert>
        </iso:rule>
    </iso:pattern>
        
    <iso:pattern name="EXT.101">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="bpmn:outgoing">A startEvent must have a outgoing subelement</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.102">
        <let name="startEvents" value="//bpmn:startEvent"/>
        <iso:rule context="bpmn:messageFlow[@sourceRef]">
            <iso:assert test="not(string(./@sourceRef) = $startEvents/@id)">A Start Event MUST NOT be a source for a message flow</iso:assert>
        </iso:rule>
    </iso:pattern>
       
    <iso:pattern name="EXT.104">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="not(bpmn:outgoing)">An End Event must not have an outgoing sequence flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.105">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="parent::*/bpmn:endEvent">An end event must be present when a start event is used in the same process level</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.106">
        <iso:rule context="bpmn:cancelEventDefinition">
            <iso:assert test="ancestor::bpmn:transaction">A cancel EndEvent is only allowed in a transaction sub-process</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.107">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="bpmn:incoming">An End Event MUST have at least one incoming Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.108">
        <let name="endEvents" value="//bpmn:endEvent"/>
        <iso:rule context="bpmn:messageFlow[@targetRef]">
            <iso:assert test="not(string(./@targetRef) = $endEvents/@id)">An End Event MUST NOT be a target for a message flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.135">
        <iso:rule context="bpmn:parallelGateway">
            <iso:assert test="count(bpmn:incoming) > 1 or count(bpmn:outgoing) > 1">A Gateway MUST have either multiple incoming Sequence Flows or multiple outgoing Sequence Flows</iso:assert>
        </iso:rule>
    </iso:pattern>
</iso:schema> 