<?xml version="1.0" encoding="utf-8"?>
<iso:schema xmlns="http://purl.oclc.org/dsdl/schematron" 
    xmlns:iso="http://purl.oclc.org/dsdl/schematron" 
    xmlns:ppn="http://ppn.lspi.uni-bamberg.de" 
    queryBinding="xslt2" schemaVersion="ISO19757-3">
    <iso:title>ISO schematron validation file for descriptive extended constraints</iso:title>
    <iso:ns prefix='bpmn' uri='http://www.omg.org/spec/BPMN/20100524/MODEL'/>
    <let name="eventDefinitions" value="bpmn:eventDefinitionRef | bpmn:messageEventDefinition | bpmn:timerEventDefinition | bpmn:escalationEventDefinition | bpmn:conditionalEventDefinition | bpmn:linkEventDefinition | bpmn:errorEventDefinition | bpmn:cancelEventDefinition | bpmn:compensationEventDefinition | bpmn:signalEventDefinition | bpmn:terminateEventDefinition" />
    <let name="associations" value="//bpmn:association" />
    <let name="textAnnotations" value="//bpmn:textAnnotation" />
    <let name="groups" value="//bpmn:group" />
    <let name="task" value="bpmn:task | bpmn:sendTask | bpmn:receiveTask | bpmn:serviceTask | bpmn:userTask | bpmn:manualTask | bpmn:scriptTask | bpmn:businessRuleTask"/>
    <let name="subProcess" value="bpmn:subProcess | bpmn:transaction | bpmn:adHocSubProcess"/>
    <let name="activity" value="$task | $subProcess | bpmn:callActivity"/>
    <let name="event" value="bpmn:startEvent | bpmn:endEvent | bpmn:intermediateThrowEvent | bpmn:intermediateCatchEvent | bpmn:boundaryEvent"/>
    <let name="gateway" value="bpmn:exclusiveGateway | bpmn:parallelGateway | bpmn:inclusiveGateway | bpmn:complexGateway | bpmn:eventBasedGateway"/>
    
    <let name="sequenceFlows" value="//bpmn:sequenceFlow"/>
    
    <!-- Your constraints go here -->
    <iso:pattern name="EXT.006">
        <iso:rule context="bpmn:sequenceFlow[@targetRef]">
            <iso:assert test="not((string(./@targetRef) = $associations/@id) or (string(./@targetRef) = $textAnnotations/@id) or (string(./@targetRef) = $groups/@id))">An Artifact MUST NOT be a target for a Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.007">
        <iso:rule context="bpmn:sequenceFlow[@sourceRef]">
            <iso:assert test="not((string(./@sourceRef) = $associations/@id) or (string(./@sourceRef) = $textAnnotations/@id) or (string(./@sourceRef) = $groups/@id))">An Artifact MUST NOT be a source for a Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>

    <iso:pattern name="EXT.008">
        <iso:rule context="bpmn:messageFlow[@targetRef]">
            <iso:assert test="not((string(./@targetRef) = $associations/@id) or (string(./@targetRef) = $textAnnotations/@id) or (string(./@targetRef) = $groups/@id))">An Artifact MUST NOT be a target for a Message Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.009">
        <iso:rule context="bpmn:messageFlow[@sourceRef]">
            <iso:assert test="not((string(./@sourceRef) = $associations/@id) or (string(./@sourceRef) = $textAnnotations/@id) or (string(./@sourceRef) = $groups/@id))">An Artifact MUST NOT be a source for a Message Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <!--
    <iso:pattern name="EXT.021">
        <let name="subProcesses" value="//bpmn:subProcess"/>
        <iso:rule context="bpmn:*[./@id = string($sequenceFlows/@sourceRef)]">
            <iso:assert test="./@id = $activity/@id or ./@id = $gateway/@id or ./@id = $event/@id and not(./@id = $subProcesses/@id and $subProcesses[string(@triggeredByEvent) = 'true'])">For a Process: Of the types of FlowNode, only Activities, Gateways, and Events can be the source. However, Activities that are Event SubProcesses are not allowed to be a source</iso:assert>
        </iso:rule>
    </iso:pattern> -->
    
    <iso:pattern name="EXT.023">
        <let name="allElements" value="//bpmn:*"/>
        <iso:rule context="bpmn:sequenceFlow[@targetRef]">
            <iso:assert test="$allElements/@id = string(./@targetRef) and ./@id = $allElements/bpmn:incoming">The target element of the sequence flow must reference the SequenceFlow definition using their incoming attributes.</iso:assert>
        </iso:rule>
        <iso:rule context="bpmn:sequenceFlow[@sourceRef]">
            <iso:assert test="$allElements/@id = string(./@sourceRef) and ./@id = $allElements/bpmn:outgoing">The source element of the sequence flow must reference the SequenceFlow definition using their outcoming attribute.</iso:assert>
        </iso:rule>
    </iso:pattern> 
    
    <iso:pattern name="EXT.026">
        <iso:rule context="bpmn:exclusiveGateway[@default] | bpmn:task[@default]">
            <iso:assert test="$sequenceFlows[@id=string(current()/@default)]/@sourceRef=./@id">If an activity or gateway references a sequenceFlow as default flow - the referenced sequence flow must reference the activity/the gateway as sourceRef</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <!--
    <iso:pattern name="EXT.028 and EXT.152">
        <let name="elements" value="//bpmn:*"/>
        <iso:rule context="bpmn:sequenceFlow">
            <iso:assert test="parent::$elements[@id = string(./@sourceRef)]/@id = parent::$elements[@id = string(./@targetRef)]/@id">If an activity or gateway references a sequenceFlow as default flow - the referenced sequence flow must reference the activity/the gateway as sourceRef</iso:assert>
        </iso:rule>
    </iso:pattern>
    -->
       
    <iso:pattern name="EXT.036">
        <iso:rule context="bpmn:process">
            <iso:assert test="not(bpmn:choreographyTask or bpmn:subChoreography or bpmn:callChoreography)">A Process must not contain Choreography Activities</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.056">
        <iso:rule context="bpmn:subProcess">
            <iso:assert test="not(bpmn:choreographyTask or bpmn:subChoreography or bpmn:callChoreography)">A SubProcess must not contain Choreography Activities</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <!--
    <iso:pattern name="EXT.076">
        <let name="dataObjects" value="//bpmn:dataObject"/>
        <iso:rule context="bpmn:dataObjectReference[@name]">
            <iso:assert test="$dataObjects[@id = ./@id and ./@name = concat(@name,' [', ./bpmn:dataState/@name, ']')]">Naming Convention: name = Data Object Name [Data Object Reference State]</iso:assert>
        </iso:rule>
    </iso:pattern>
    -->
    
    <iso:pattern name="EXT.079">
        <iso:rule context="bpmn:subProcess">
            <iso:assert test="not(bpmn:ioSpecification)">InputOutputSpecifications are not allowed in SubProcesses</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.084">
        <let name="inputSets" value="//bpmn:inputSet"/>
        <iso:rule context="bpmn:dataInput">
            <iso:assert test="$inputSets/bpmn:dataInputRefs = ./@id">A DataInput must be referenced by at least one InputSet</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.088">
        <let name="outputSets" value="//bpmn:outputSet"/>
        <iso:rule context="bpmn:dataOutput">
            <iso:assert test="$outputSets/bpmn:dataOutputRefs = ./@id">A DataOutput must be referenced by at least one OutputSet</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.096">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="not(bpmn:incoming)">A Start Event must not have an incoming sequence flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.097">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="parent::*/bpmn:startEvent">A Start event must be present when an End event is used in the same process level</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.099">
        <let name="callActivities" value="//bpmn:callActivity"/>
        <iso:rule context="bpmn:process[./@id = string($callActivities/@calledElement)]">
            <iso:assert test="not(count(./bpmn:startEvent) = (count(./bpmn:startEvent/bpmn:eventDefinitionRef/..) + count(./bpmn:startEvent/bpmn:messageEventDefinition/..) + count(./bpmn:startEvent/bpmn:timerEventDefinition/..) + count(./bpmn:startEvent/bpmn:escalationEventDefinition/..) + count(./bpmn:startEvent/bpmn:conditionalEventDefinition/..) + count(./bpmn:startEvent/bpmn:linkEventDefinition/..) + count(./bpmn:startEvent/bpmn:errorEventDefinition/..) + count(./bpmn:startEvent/bpmn:cancelEventDefinition/..) + count(./bpmn:startEvent/bpmn:compensationEventDefinition/..) + count(./bpmn:startEvent/bpmn:signalEventDefinition/..) + count(./bpmn:startEvent/bpmn:terminateEventDefinition/..)))">Referenced process must have at least one None Start Event</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.100">
        <iso:rule context="bpmn:subProcess/bpmn:startEvent | bpmn:transaction/bpmn:startEvent | bpmn:adHocSubProcess/bpmn:startEvent">
            <iso:assert test="not(./$eventDefinitions)">No EventDefinition is allowed for Start Events in Sub-Process definitions</iso:assert>
        </iso:rule>
    </iso:pattern>
        
    <iso:pattern name="EXT.101">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="bpmn:outgoing">A startEvent must have a outgoing subelement</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.102">
        <let name="startEvents" value="//bpmn:startEvent"/>
        <iso:rule context="bpmn:messageFlow[@sourceRef]">
            <iso:assert test="not(string(./@sourceRef) = $startEvents/@id)">A Start Event MUST NOT be a source for a message flow</iso:assert>
        </iso:rule>
    </iso:pattern>
       
    <iso:pattern name="EXT.104">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="not(bpmn:outgoing)">An End Event must not have an outgoing sequence flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.105">
        <iso:rule context="bpmn:startEvent">
            <iso:assert test="parent::*/bpmn:endEvent">An end event must be present when a start event is used in the same process level</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.106">
        <iso:rule context="bpmn:cancelEventDefinition">
            <iso:assert test="ancestor::bpmn:transaction">A cancel EndEvent is only allowed in a transaction sub-process</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.107">
        <iso:rule context="bpmn:endEvent">
            <iso:assert test="bpmn:incoming">An End Event MUST have at least one incoming Sequence Flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.108">
        <let name="endEvents" value="//bpmn:endEvent"/>
        <iso:rule context="bpmn:messageFlow[@targetRef]">
            <iso:assert test="not(string(./@targetRef) = $endEvents/@id)">An End Event MUST NOT be a target for a message flow</iso:assert>
        </iso:rule>
    </iso:pattern>
    
    <iso:pattern name="EXT.135">
        <iso:rule context="bpmn:parallelGateway">
            <iso:assert test="count(bpmn:incoming) > 1 or count(bpmn:outgoing) > 1">A Gateway MUST have either multiple incoming Sequence Flows or multiple outgoing Sequence Flows</iso:assert>
        </iso:rule>
    </iso:pattern>
    
</iso:schema> 